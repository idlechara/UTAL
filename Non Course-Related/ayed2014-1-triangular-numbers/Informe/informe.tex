\documentclass[11pt]{utalcaDoc}
\usepackage{alltt}
\usepackage{underscore}
\usepackage[latin1]{inputenc}
\usepackage[activeacute,spanish]{babel}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{ae}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmic}
\input{spanishAlgorithmic}

\title{{\bf Algoritmos y estructuras de datos}\\Tarea 1 - Informe modelo}
\author{Erik Regla\\ eregla09@alumnos.utalca.cl}
\date{1 de Mayo del 2014}

\begin{document}
\renewcommand{\figurename}{Figura~}
\renewcommand{\tablename}{Tabla~}

\maketitle

\section{Introducción}
Un número triangular es aquel que puede recomponerse en la forma de un triángulo equilátero (por convención, el primer número triangular es el 1). Los números triangulares, junto con otros números figurados, fueron objeto de estudio por Pitágoras y los Pitagóricos, quienes consideraban sagrado el 10 escrito en forma triangular, y al que llamaban Tetraktys.

En 1796, el matemático y científico alemán Carl Friedrich Gauss descubrió que todo entero positivo puede representarse como la suma de un máximo de tres números triangulares, hecho que describió en su diario con la misma palabra que usara Arquímedes en su famoso descubrimiento: "¡Eureka! num = $\triangle$ + $\triangle$ + $\triangle$." 

Nótese que este teorema no implica que los números triangulares son diferentes (como ocurre en el caso de 20 = 10 + 10), ni tampoco que debe haber una solución con tres números triangulares que sean diferentes de cero. Se trata de un caso especial del teorema del número poligonal de Fermat.\footnote{Extraido de wikipedia: http://es.wikipedia.org/wiki/Número_triangular}

Para esta tarea se pide verificar la conjetura mencionada anteriormente, para el rango $[1\ldots 10^9]$ como a su vez para cada número de forma individual.

\section{Análisis del Problema}

La conjetura dice que un número natural puede descomponerse en la suma de a lo más tres numeros triangulares por lo tanto, podríamos decir que cualquier número natural $n$ sigue la Propiedad \ref{eq:caso_base}.

\begin{equation} \label{eq:conjetura}
	n=\triangle_3+\triangle_3+\triangle_3
\end{equation}
donde $n$ es un número natural.

El $n$-esimo número triangular viene dado por la Ecuación \ref{eq:sumatoria}.

\begin{equation} \label{eq:sumatoria}
	\frac{n(n+1)}{2}
\end{equation}

En donde $n$ es el índice del número triangular pedido.

Puede que se de el caso donde $\triangle_2$ y $\triangle_3$ sean iguales a 0 (lo cual ocurre cuando el número efectivamente es un triangular), lo que nos deja el primer caso: 

\begin{equation} \label{eq:caso_base}
	n=\triangle_{1}
\end{equation}

Lo cual nos lleva a pensar, que la primera verificación para ver si el numero cumple, es verificar primero si es triangular. Para eso, almacenamos en una lista los numeros triangulares generados por \eqref{eq:sumatoria}, a modo de poder tenerlos a mano fácilmente.

\begin{algorithm}
\begin{algorithmic}[1]
\REQUIRE Lista $L$ vacía, $S$ cantidad de números a generar.
\ENSURE $L$ contiene numeros triangulares ordenados crecientemente
\FOR {$i \leftarrow 0 \ldots S$}
\STATE $L[i] \leftarrow = \frac{n(n+1)}{2}$
\ENDFOR
\RETURN $L$
\end{algorithmic}
\caption{Generador de números triangulares}\label{alg:generador_triangulares}
\end{algorithm}

Entonces, habiendo planteado el Algoritmo \ref{alg:generador_triangulares} y la Ecuación \ref{eq:sumatoria}, podemos decir que un número natural se compone de a lo más tres números triangulares, lo cual puede ser reescrito como:

\begin{equation} \label{eq:conjetura_con_indices}
	n=L[a_1]+L[a_2]+L[a_3]
\end{equation}

donde $L[a]$ es el $a$-ésimo numero triangular y $L[a_1] \leq L[a_2] \leq L[a_3]$.\footnote{Obviamente $a_1  \leq a_2  \leq a_3$}

Si no se cumple lo planteado en \ref{eq:caso_base}, estamos frente a un número que bien podría estar compuesto por dos o bien tres numeros triangulares. 

Por ende, si tenemos un número $\triangle_{1}$ que es menor o igual a un $n$ buscado, entonces, podríamos decir que este es el triangular mayor asociado a $n$. En caso de que este sea igual, se cumple \ref{eq:caso_base}, en caso de que sea estrictamente menor estamos frente al caso planteado en la Ecuación \ref{eq:caso_base_2} o a la Ecuación \ref{eq:caso_base_3}.

\begin{equation} \label{eq:caso_base_2}
	n=\triangle_1+\triangle_2
\end{equation}
\begin{equation} \label{eq:caso_base_3}
	n=\triangle_1+\triangle_2+\triangle_3
\end{equation} 

Despejando $\triangle_{3}$ de la Ecuación \ref{eq:caso_base_3} tenemos:
\begin{equation} \label{eq:caso_base_3_n_despejado}
	\triangle_3= n - (\triangle_1+\triangle_2)
\end{equation} 

Dada la naturaleza de los números y las ecuaciones anteriormente descritas, además podemos afirmar algunas propiedades:
\begin{equation} \label{eq:propiedad_1}
	\triangle_1 + \triangle_2 + \triangle_3 = n \rightarrow \triangle_1, \triangle_2, \triangle_3 \geq \frac{n}{3}
\end{equation}
\begin{equation} \label{eq:propiedad_2}
	\triangle_1 \geq \frac{2n}{3} \rightarrow \triangle_3 \leq \triangle_2 \leq \frac{n}{3}
\end{equation}

Es obvio que gracias a la Ecuación \ref{eq:propiedad_2} podemos ya descartar $\frac{2n}{3}$ de los casos en el caso de que el número a buscar sea mayor o igual a $\frac{2n}{3}$. Para el resto de los casos, solo hay que cambiar el valor de $\triangle_1$ y automáticamente el rango es ajustado.

Por lo cual podemos afirmar que si tenemos un potencial $\triangle_2$, automáticamente tenemos el valor de $\triangle_3$ sin necesidad de mayores cálculos de nuestra parte. Además, aplicando el principio de localidad de memoria tenemos:

\begin{algorithm}
\begin{algorithmic}[1]
\REQUIRE $N$ un número natural, $I$ es el índice desde el cual se comienza a buscar, $T$ es un arreglo de números triangulares
\ENSURE $I$ contiene el índice del triangular relativo directamente menor o igual
\IF{$T[I] \leq N$ y $T[I+1] > N $}
	\RETURN $I$
\ELSE
	\WHILE {$T[I] > N$}
		\STATE $I \leftarrow I-1$
	\ENDWHILE
	\WHILE {$N < T[I+1]$}
		\STATE $I \leftarrow I+1$
	\ENDWHILE
\ENDIF
\end{algorithmic}
\caption{Búsqueda de triangular relativo o menor}\label{alg:indizado}
\end{algorithm}

Este algoritmo si bien es O($n$), gracias al principio de localidad y a las propiedades de los números triangulares, en promedio solo le toma tres operaciones llegar al índice buscado, salvo algunos casos especificos, los cuales por no representar una cantidad importante serán despreciados.

\begin{algorithm}
\begin{algorithmic}[1]
\REQUIRE $N$ un número natural
\ENSURE $T1$, $T2$ y $T3$ son los índices de la descomposción de $N$ dada la conjetura \ref{eq:conjetura}; Arroja un error en caso de fallar.
\STATE $T_1 \leftarrow $ indice triangular relativo a $N$
\STATE $\Delta T_1, \Delta T_2, \Delta T_3 \leftarrow 0$

\IF{$L[T_1] = N$}
	\RETURN $T_1$
\ELSE

	\WHILE{$L[T_1-\Delta T_1] \geq \frac{n}{3}$}
		\STATE $T_2 \leftarrow $ indice triangular relativo a $(N-L[T_1-\Delta T_1])$
		\IF{$L[T_1 - \Delta T_1]+L[T_2] = N$}
			\RETURN $T_1-\Delta T_1, T_2$
		\ELSE
			\WHILE{$L[T_1-\Delta T_1]+L[T_2-\Delta T_2] \geq \frac{2n}{3}$}
				\STATE $T_3 \leftarrow $ indice triangular relativo a $(N-(L[T_1-\Delta T_1]+L[T_2-\Delta T_2]))$
				\IF{$L[T_1-\Delta T_1]+L[T_2-\Delta T_2]+L[t_3] = N$}
					\RETURN $T_1, T_2, T_3$
				\ENDIF
				\STATE $\Delta T_2 \leftarrow \Delta T_2 + 1$
			\ENDWHILE
		\ENDIF
		\STATE $\Delta T_1 \leftarrow \Delta T_1 + 1$
	\ENDWHILE
\ENDIF
\RETURN ERROR
\end{algorithmic}
\caption{Descomposción de números naturales}\label{alg:descomp}
\end{algorithm}

Aplicando algo de matemática al Algoritmo \ref{alg:descomp}, es facil observar que el algoritmo anteriormente descrito es O($n^2$).\footnote{Sin embargo, experimentalmente, la curva de rendimiento es relativamente cercana a $n^{\approx0.2}$}, lo cual tiene sentido, dado que n en este caso no representa el número de entradas, sinó, el número a calcular. Usualmente, la verificación no toma más de 3 pasos, llegando experimentalmente a un máximo de 20.

Experimentalmente, resultó no ser una buena idea implementar la verificación de la conjetura, en especial para $10^9$ dada la cantidad de verificaciones que hay que realizar. Pero, si queremos ver si efectivamente $n$ es un numero que cumple con esta. Para esto usamos:

%\begin{equation} 
	\begin{align}
		n=a_i\\
		b=a_i+a_b \label{eq:suma_de_dos_triangulares}\\ 
		c=b_i+a_i \label{eq:suma_de_tres_triangulares}
	\end{align}
%\end{equation}

Sean $a$, $b$ y $c$ dos números naturales que cumplen con la conjetura utilizando 1, 2 y 3 términos respectivamente.

Como antecedente adicional, se precalculó el número de números triangulares para $10^9$, los cuales son $44720$ numeros triangulares, siendo $\triangle_{44720} = 999961560$. Númericamente, es correcto afirmar que para $10^9$ se cumple:

\begin{equation}
	\#\triangle_{10^9} \leq \sqrt{10^9}
\end{equation}

Lo cual nos garantiza que cualquier operación efectuada sobre la cantidad misma de triangulares tendrá un costo de O($n$).\footnote{Para $10^9$ el costo teórico esperado es de $\frac{\sqrt{10^9}}{44720} = \approx 0.7071 \leq 1$.}

Entonces, una de las operaciones que se pueden ejecutar a un costo relativamente aceptable, es la obtención de los números que pertenecen a la familia descrita en la Equación \ref{eq:suma_de_dos_triangulares}.

\begin{algorithm}
\begin{algorithmic}[1]
\REQUIRE $T$ es un arreglo que contiene números triangulares, $A$ es un arreglo de bits inicializado en 0.
\ENSURE $A$ contiene marcados con $1$ los indices que refieren a un numero del cual se ha comprobado su conjetura y pertenecen al tipo indicado en la Ecuación \ref{eq:suma_de_dos_triangulares}
\FOR{$i \leftarrow 0 \ldots T_{size}$}
	\FOR{$j\leftarrow i \ldots T_{size}$}
		\IF{$i \times j \geq T_{size}$}
			\STATE break
		\ENDIF
		\STATE $A[i \times j] \leftarrow 1$
	\ENDFOR
\ENDFOR
\end{algorithmic}
\caption{Obtención de triangulares mediante suma}\label{alg:suma_triangular}
\end{algorithm}

Lo cual nos da aproximadamente $\frac{(n^2)-n}{2}$ combinaciones, de las cuales un número indeterminado ya están repetidas posiblemente.\footnote{Experimentalmente, después de esta etapa, para $10^9$ quedan $671058847$ numeros por verificar que realmente cumplen la conjetura.} Después de este punto, otra operación que sería relativamente económica sería la obtención de los números que cumplen con el criterio de la Ecuación \ref{eq:suma_de_tres_triangulares} la cual consiste en copiar sobre el mismo resultado, los resultados anteriores desplazados en un triangular.

\begin{algorithm}
\begin{algorithmic}[1]
\REQUIRE $T$ es una lista de números triangulares ordenados crecientemente, $A_t$ es un arreglo de bits que contiene el resultado del Algoritmo \ref{alg:indizado}, $A_r$ es un arreglo de bits que contiene el resultado del Algoritmo \ref{alg:indizado} junto con la iteración producida. $D$ es la cantidad de desplazamientos a ejecutar.
\ENSURE $A_r$ contiene los resultados de A_t desplzadados, cumpliendo el criterio de la Ecuación \ref{eq:suma_de_tres_triangulares}

\FOR{$j \leftarrow 0 \ldots D$}
	\FOR{$i \leftarrow 0 \ldots A_t{t_{size}}$}
		\IF{$A_r[i] + T[j]$}
			\STATE break
		\ENDIF
		\STATE $A_r[i+T[j]] \leftarrow 1$
	\ENDFOR
\ENDFOR
\end{algorithmic}
\caption{Desplazamiento de resultados para cálculo de triangulares}\label{alg:suma_triangular_desplazada}
\end{algorithm}

Como es posible observar, el Algoritmo \ref{alg:suma_triangular_desplazada} tiene un costo de O$(mn)$, siendo $m$ la cantidad de desplzamientos a aplicar y $n$ el tamaño del arreglo, que en este caso es $10^9$. Experientalmente, luego de $22$ iteraciones, para $10^9$ términos la cantidad a verificar de estos se reduce de $671058847$ términos a $192436$, cantidad a la cual usar el algoritmo de descomposición se vuelve feasible.\footnote{La cantidad de iteraciones es directamente proporcional de términos que se descartan, dada la distribución de los numeros triangulares. La cantidad de iteraciones de por si, dependerá de la naturaleza del problema.}

A este punto, ya es posible visualizar la ejecución del programa para verificar la conjetura en el Algoritmo \ref{alg:programa_principal}.

\begin{algorithm}
\begin{algorithmic}[1]
\REQUIRE $N$ es el rango de números a verificar, $A_t$ y $A_r$ son arreglos de bits inicializads en 0. $T$ es un arreglo de números inicializado en 0. $D$ es la cantidad de desplazamientos a ejecutar.
\ENSURE retorna \TRUE si la conjetura es verificada para todo número en el rango

\STATE $T \leftarrow generarNúmerosTriangulares(N)$
\STATE $copiar resultados de T a A_t$
\STATE $A_r \leftarrow obtenerTriangularesMedianteSuma(A_t, D, N)$
\FOR{$i \leftarrow 0 \ldots A_r{A_{r_{size}}}$}
	\IF{$A_r[i] \neq 1$}
		\STATE $A_r[i] \leftarrow verificarConjetura(i)$
	\ENDIF
\ENDFOR
\FOR{$i \leftarrow 0 \ldots A_r{A_{r_{size}}}$}
	\IF{$A_r[i] \neq 1$}
		\RETURN \FALSE
	\ELSE
		\RETURN \TRUE
	\ENDIF
\ENDFOR
\end{algorithmic}
\caption{Desplazamiento de resultados para cálculo de triangulares}\label{alg:programa_principal}
\end{algorithm}

\section{Detalles de implementación}
\subsection{Memoria}
El consumo de memoria siempre es un problema. Considerando el peso en memoria de un tipo de dato \textit{Long}\footnote{Se refiere al tipo de dato \textit{Long Integer} dado que es imposible almacenar en un tipo de dato mayor los números del rango solicitado. Un \textit{Long Integer} pesa 32 bits.}, para un computador normal, está fuera de lo que uno puede manejar en memoria. Además, usar la memoria virtual no es una opción, dada lo baja de la velocidad de esta. Para estos fines, se recomienda la aplicación de estructuras adecuadas, como por ejemplo \textit{mapas de bits}.\footnote{Un mapa de bits es una estructura que solo almacena bits en un arreglo. Dados que estos pueden ser interpretados como \textit{verdadero} o \textit{falso}, proveen de una solución simple para poder comprimir los datos a utilizar. Sin embargo, implementarlos supone un costo adicional en operaciones de comparación y asignación, pero en este caso, dada la naturaleza de nuestro algoritmo, podemos sobrellevar el peso que esta técnica implica. http://en.wikipedia.org/wiki/Bit\_array}

\subsection{Lenguaje}
Parte de ir tras un problema es elegir el arma adecuada. Sin mucha discusión, elegimos \textit{C++} como lenguaje objetivo para poder implementar la solución. Dada la libertad que proveen las librerías de entrada y salida estándar, junto con la flexibilidad provista para el manejo de memoria, es la opción obvia para este caso.

\subsection{Tiempos de ejecución}
Sin mucho que agregar, teóricamente sin mucho esfuerzo, el tiempo de ejecución debería ser O($n^3$), sin embargo, dado que este algoritmo fue desarrollado para un caso muy especifico, se habla de que es en realidad O($kn$) con una $k$ constante la cual consideramos que si bien es mayor que $1$ nunca es mayor o igual que $n$, la cual está en función de las operaciones de comparación implementadas y de gestión de memoria.

\subsection{Compilación y Ejecución}
Se recomienda usar \textit{Linux G++ 11} como compilador. 
Compilación para versión a entregar:
\begin{alltt} 
\centering
g++ -Wall -std=c++0x t1.cpp -o t1.out
\end{alltt}

Compilación incluyendo salidas para \textit{debug}:
\begin{alltt}
\centering
g++ -Wall -std=c++0x -DDEBUG t1.cpp -o t1.out
\end{alltt}

Ejecución:
\begin{alltt}
\centering
t1.out < input.in > output.out
\end{alltt}

\section{Notas}
No se han incluido como sección separada los gráficos ni los diagramas de estado, dado que este es un informe modelo con la finalidad de explicar el funcionamiento de un algoritmo implementado. Dada la profundidad de la explicación y las aclaraciónes experimentales hechas durante el desarrollo de este, agregar los diagramas de estado y resultados de pruebas no suponen complemento alguno a la comprensión del problema.

Cabe destacar que esta es solo una de las soluciones para este problema. Por ende, podría no ser eficiente y no ser la mejor, pese a eso, para efectos del problema planteado, lo resuelve en un tiempo aceptable.
\end{document}


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































%%Como premio, si es que leíste todo el documento, te dejo el link donde puedes encontrar el programa: 
%%
%%	

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































