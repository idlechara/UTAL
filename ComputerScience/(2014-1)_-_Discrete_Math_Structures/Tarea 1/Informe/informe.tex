\documentclass[11pt]{utalcaDoc}

\usepackage{listings}
\usepackage{alltt}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{ae}
\usepackage{amsmath}
\usepackage{bbm}


\title{{\bf Estructuras computacionales discretas}\\Tarea 1}
\author{Erik Regla, Alejandro Naranjo \\ \tt{eregla09@alumnos.utalca.cl} , \tt{anaranjo11@alumnos.utalca.cl}}
\date{1 de Mayo del 2014}

\lstset{breaklines=true} 

\numberwithin{equation}{section}
\begin{document}
\renewcommand{\figurename}{Figura~}
\renewcommand{\tablename}{Tabla~}

\maketitle

\section{Inducción Estructural sobre BubbleSort}

\subsection{Funciones Auxiliares}
\[ max(A,B)=
 \begin{cases}
 A, \qquad& \text{si B $=\phi$}.\\
 A, \qquad& \text{si A $>$ B}.\\
 B, \qquad& \text{si A $=\phi$}.\\
 B, \qquad& \text{si A $<$ B}\\
\end{cases} \]

\[ removeItem(L,n)=
 \begin{cases}
 \to\phi, \qquad& \text{si L $= $ $\to$n}.\\
 \to$ L$', \qquad& \text{si L $=$ $\to$L$'\to$n}.\\
 \textit{removeItem}\text{(L$'$, n)}\to$k$,\qquad& \text{si L $=$ $\to$L$'\to$k}.
\end{cases} \]

\[ bubbleUp(L)=
 \begin{cases}
 \to\phi, \qquad& \text{si L $=$ $\to\phi$}.\\
 \to$ k$, \qquad& \text{si L $=$ $\to$ k}.\\
 \textit{max(bubbleUp}\text{(L$'$), k)}, \qquad& \text{si L $=$ $\to$L$'\to$ k}.\\
 \textit{max}\text{(j, k)}, \qquad& \text{si L $=$ $\to$ j $\to$ k}.
\end{cases} \]

\subsection{Definición de BubbleSort}
\[ BubbleSort(L)=
 \begin{cases}
 $k$, \qquad& \text{si L $=$ $\to$ k}.\\
 \textit{BubbleSort(removeItem(L,bubbleUp(L)))} \to \textit{bubbleUp(L)}, \qquad& \text{si L $=$ L$' \to$ k}\\
\end{cases} \]

\subsection{Bonus 1}
Ordenar lista L = $\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2.
\newline
\newline
BubbleSort($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2) = BubbleSort( removeItem(L, BubbleUp(L)) ) $\to$ BubbleUp(L)
\subsubsection{Iteración 1}
 BubbleSort($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2) = BubbleSort( removeItem(L, BubbleUp(L)) ) $\to$ BubbleUp(L)
 \begin{center}
    bubbleUp($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2)\\
    max( bubbleUp( $\to$ 5 $\to$ 1 $\to$ 8), 2)\\
    max( max( bubbleUp($\to$ 5 $\to$ 1), 8), 2)\\
    max( max( max(5, 1), 8), 2)\\
    max( max(5, 8), 2)\\
    max( 8, 2)\\
    8\\
 \end{center}
 BubbleSort($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2) = BubbleSort( removeItem(L, 8) ) $\to$ 8
 \begin{center}
    removeItem($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2, 8)\\
    removeItem($\to$ 5 $\to$ 1 $\to$ 8, 8) $\to$ 2\\
    $\to$ 5 $\to$ 1 $\to$ 2\\
 \end{center}
 BubbleSort($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2) = BubbleSort( $\to$ 5 $\to$ 1 $\to$ 2 ) $\to$ 8

\subsubsection{Iteración 2}
 BubbleSort( $\to$ 5 $\to$ 1 $\to$ 2 ) = BubbleSort( removeItem(L, BubbleUp(L)) ) $\to$ BubbleUp(L)
 \begin{center}
   bubbleUp($\to$ 5 $\to$ 1 $\to$ 2)\\
   max( bubbleUp($\to$ 5 $\to$ 1), 2)\\
   max( max( 5, 1), 2)\\
   max( 5, 2)\\
   5\\
 \end{center}
 BubbleSort($\to$ 5 $\to$ 1 $\to$ 2) = BubbleSort( removeItem(L, 5) ) $\to$ 5
 \begin{center}
    removeItem($\to$ 5 $\to$ 1 $\to$ 2, 5)\\
    removeItem($\to$ 5 $\to$ 1, 5) $\to$ 2\\
    removeItem($\to$ 5, 5) $\to$ 1 $\to$ 2\\
    $\to\phi$ $\to$ 1 $\to$ 2\\
    $\to$ 1 $\to$ 2\\
 \end{center}
 BubbleSort($\to$ 5 $\to$ 1 $\to$ 2) = BubbleSort( $\to$ 1 $\to$ 2 ) $\to$ 5\newline
 BubbleSort($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2) = BubbleSort($\to$ 1 $\to$ 2 ) $\to$ 5 $\to$ 8
 
\subsubsection{Iteración 3}
 BubbleSort($\to$ 1 $\to$ 2 ) = BubbleSort( removeItem(L, BubbleUp(L)) ) $\to$ BubbleUp(L)
 \begin{center}
   bubbleUp($\to$ 1 $\to$ 2)\\
   max( 1, 2)\\
   1\\
 \end{center}
 BubbleSort($\to$ 1 $\to$ 2) = BubbleSort( removeItem(L, 2) ) $\to$ 2
 \begin{center}
    removeItem($\to$ 1 $\to$ 2, 2)\\
    $\to$ 1\\
 \end{center}
 BubbleSort($\to$ 1 $\to$ 2) = BubbleSort( $\to$ 1 ) $\to$ 2\newline
 BubbleSort($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2) = BubbleSort($\to$ 1) $\to$ 2 $\to$ 5 $\to$ 8\newline
 \newline
 Así finalmente:
 \begin{center}
     BubbleSort($\to$ 5 $\to$ 1 $\to$ 8 $\to$ 2) = $\to$ 1 $\to$ 2 $\to$ 5 $\to$ 8
 \end{center}

\subsection{Bonus 2}
La forma en que se ha definido \textit{BubbleSort(L)}, nos sugiere que la lista L se quedará ordenada de la siguienteForma.
\begin{equation*}
\textit{BubbleSort(}\mathcal{L}_{\mathbbm{N}}\textit{)} = \textit{BubbleSort(} \mathcal{L}\backslash\text{max(}\mathcal{L}\text{)} \textit{)} \to \text{max(}\mathcal{L}\text{)}
\end{equation*}
Pues \textit{removeItem} quita de la lista a ordenar el mayor término, entregado por \textit{bubbleUp}, pero además este mismo término es anexado al final de la lista posteriormente.
Por lo tanto, \textit{BubbleSort(L)} es efectivamente la lista L, ordenada de menor a mayor.

\newpage

\section{Inducción sobre expresiones regulares}
\subsection{Demostrar que $(0\cdot(1\cdot0)\star\cdot1)|(0\cdot1)$ es una expresión regular.}
\begin{eqnarray*}
	(0\cdot(1\cdot0)\star\cdot1)&|&(0\cdot1)\\
	(0\cdot (ER)\star\cdot1)&|&(ER)\\
	(0\cdot ER\star\cdot1)&|& ER\\
	(0\cdot ER\cdot1)&|& ER\\
	(0\cdot ER)&|& ER\\
	(ER)&|& ER\\
	ER &|& ER\\
   	&ER&\\
\end{eqnarray*}

\subsection{Explique por qué $(0(0|1\star|00)$ no es una expresión regular. Explique como corregir estos problemas.}
 \begin{eqnarray*}
 	(0( 0| 1\star &|& 00)\\
 	(0( 0|ER &|& 00)\\
 	(0( ER &|& 00)\\
 \end{eqnarray*}
	De esto se desprende que ER|00 no es una expresión regular, para ello, debemos ańadir una definición para $\Sigma$ que permita juntar 2 o más caracteres de éste. Así:
 \begin{equation}
 	\forall \text{ c, d } \in \Sigma \text{ , cd es una ER }
 \end{equation} \label{EQ:CD}
	Y luego, de vuelta al ejercicio:
 \begin{eqnarray*}
 	(0(ER&|&00)\\
 	(0(ER&|&ER)\\
 	(0&(ER)&\\
 	&(0ER&\\
 	&(ER&\\
 \end{eqnarray*}
 	Y ahora, nuevamente hemos llegado a algo que no es expresión regular ("(ER"). Para solucionar este nuevo problema, debemos generar una nueva definición para $\Sigma$.
 \begin{equation}
 	\text{Si } E_1 \text{es una ER, (}E_1 \wedge E_1\text{)} \text{ son ERS.}
 \end{equation}\label{EQ:PARENTESIS_INDIVIDUALES}
 
 Luego, finalmente, las nuevas definiciones requeridas para comprobar que $(0(0|1\star|00)$ es una expresión regular son \ref{EQ:CD} y \ref{EQ:PARENTESIS_INDIVIDUALES}.

\subsection{Demostración del número de operadores y paréntesis}
Contraejemplo:

Si para toda expresión regular válida se cumple la Propiedad \ref{EQ:REGEX_RULE}, entonces, para $0****$ también debería cumplirse.

\begin{align}
0****\label{EQ:REGEX_00}\\
\overbrace{0*}^\text{ER}&*** \label{EQ:REGEX_01}\\
\overbrace{ER*}^\text{ER}&** \nonumber\\
\overbrace{ER*}^\text{ER}&* \nonumber\\
\overbrace{ER*}^\text{ER}& \nonumber\\
ER&\nonumber
\end{align}


Dado que la Expresión Regular \ref{EQ:REGEX_01} es una expresión regular válida:
\begin{align}
\#operadores &\leq \#par\'{e}ntesis + \#carácteres\_de\_\Sigma \label{EQ:REGEX_RULE}\\
4 &\leq 0+1 \nonumber\\
4 &\leq 1 \label{EQ:REGEX_02}
\end{align}

Por lo cual, podemos afirmar usando \ref{EQ:REGEX_02}, que la Expresión Regular \ref{EQ:REGEX_00}, no cumple con \ref{EQ:REGEX_RULE}, por ende no es posible demostrar esta regla.

\subsection{Bonus}


\begin{align}
\Phi \label{EQ:REGEX_BONUS}\\
\overbrace{\Phi}^\text{ER} \nonumber\\
ER\nonumber
\end{align}

Dado que la Expresión Regular \ref{EQ:REGEX_BONUS} es una expresión regular válida:
\begin{align}
\#operadores &\leq \#par\'{e}ntesis + \#carácteres\_de\_\Sigma \nonumber\\
0 &\leq 0 + 0 \nonumber\\
0 &\leq 0 \label{EQ:REGEX_BONUS_1}
\end{align}

Por lo cual, usando \ref{EQ:REGEX_BONUS_1}, podemos afirmar que la Expresión Regular \ref{EQ:REGEX_BONUS} tiene la misma cantidad de paréntesis que de elementos de $\Sigma$.
\newpage

\section{Inducci\'on para resolver sumatorias} 
Demostrar que:
\begin{equation*}
 \sum_{p=1}^{k} pH_{p} = \frac{k(k+1)}{2}H_{k} - \frac{k(k-1)}{4}
\end{equation*}
\begin{equation*}
 \textrm{Donde } H_{p} = \sum_{i=1}^{n} H_{i} = 1 + \frac{1}{2} + ...  + \frac{1}{p} \textrm{ es el p-'esimo n'umero arm'onico.}
\end{equation*}
\subsection{BI:}
Para 1.
\begin{equation*}
 \sum_{p=1}^{1} pH_{p} = \frac{1(1+1)}{2}H_{1} - \frac{1(1-1)}{4} = 1*H_{1}
\end{equation*}
\begin{eqnarray*}
  1*H_{1} - 0 &=& 1*H_{1}\\
  1*1 &=& 1*1\\
\end{eqnarray*}

Para 2.
\begin{equation*}
 \sum_{p=1}^{2} pH_{p} = \frac{2(2+1)}{2}H_{2} - \frac{2(2-1)}{4} = 1*H_{1} + 2*H_{2}
\end{equation*}
\begin{eqnarray*}
 3 + (1 + \frac{1}{2}) - \frac{1}{2} &=& 1*1 + 2*(1 + \frac{1}{2})\\
 3*\frac{3}{2} - \frac{1}{2} &=& 1 + 2(\frac{3}{2}\\
 \frac{9}{2} - \frac{1}{2} &=& 1 + 3\\
 4 &=& 4\\
\end{eqnarray*}
Por lo tanto, hemos comprobado que la base de la inducci'on se cumple.

\subsection{HI:}
\begin{equation*}
 \sum_{p=1}^{k} pH_{p} = \frac{k(k+1)}{2}H_{k} - \frac{k(k-1)}{4}
\end{equation*}

\subsection{TI:}
\begin{equation*}
 \sum_{p=1}^{k+1} pH_{p} = \frac{(k+1)(k+2)}{2}H_{k+1} - \frac{k(k+1)}{4} =
 \frac{k(k+1)}{2}H_{k} - \frac{k(k-1)}{4} + (k+1)*H_{k+1}
\end{equation*}
\begin{eqnarray*}
 \frac{k(k+1)}{2}H_{k} &-& \frac{k(k-1)}{4} + (k+1)*H_{k+1}\\
 \frac{k(k+1)}{2}H_{k} &-& \frac{k(k-1)}{4} + (k+1)*\left(H_{k} + \frac{1}{k+1}\right)\\
  H_{k}\left( \frac{k(k+1)}{2} + k+1 \right) &-& \frac{k(k-1)}{4} + 1\\
  H_{k}\left( \frac{k^2 + k + 2 k + 2}{2}\right) &-& \frac{k^2 - k + 4}{4}\\
  H_{k}\left( \frac{(k+1)(k+2)}{2}\right) &-& \frac{k^2 + k - 2 k + 4}{4}\\  
  H_{k}\left( \frac{(k+1)(k+2)}{2}\right) &-& \left( \frac{k(k+1)}{4} - \frac{2(k+2)}{4} \right)\\
  H_{k}\left( \frac{(k+1)(k+2)}{2}\right) &-& \frac{k(k+1)}{4} + \frac{k+2}{2} 
  \qquad\textrm{ ,con }\frac{k+2}{2} \textrm{ = }\frac{(k+2)(k+1)}{2(k+1)} \\ 
  \frac{(k+1)(k+2)}{2} \left( H_{k} + \frac{1}{k+1} \right) &-& \frac{k(k+1)}{4}\\
\end{eqnarray*}
\begin{equation*}
  \textrm{As'i finalmente:}\qquad\frac{(k+1)(k+2)}{2}H_{k+1} - \frac{k(k+1)}{4}
\end{equation*}
Por lo tanto, 2.3 se cumple.

			\newpage
\section{Inducción sobre fórmulas lógicas}
\subsubsection{Base inductiva}
Definiremos los operadores lógicos $\vee$, $\wedge$, $\Rightarrow$ y $\Leftrightarrow$:

Sea $1=Verdadero$ y $0=Falso$:

\[ A \vee B =
 \begin{cases}
 0,	\qquad& \text{si $A=0$ y $B=0$}.\\
 1,	\qquad& \text{en otro caso}.\\
\end{cases} \]

\[ A \wedge B =
 \begin{cases}
 1, 	\qquad& \text{si $A=1$ y $B=1$}.\\
 0,	 	\qquad& \text{en otro caso}.\\
\end{cases} \]

\[ A \rightarrow B =
 \begin{cases}
 0,	 	\qquad& \text{si $A=1$ y $B=0$}.\\
 1,		\qquad& \text{en otro caso}.\\
\end{cases} \]

\[ A \Leftrightarrow B =
 \begin{cases}
 1, 	\qquad& \text{si $A$ y $B$ son iguales}.\\
 0,	 	\qquad& \text{en otro caso}.\\
\end{cases} \]


\begin{align}
\left(\bigvee\limits_{i=1}^{1}X_i\right)\rightarrow Y &= x_1 \rightarrow Y \Leftrightarrow \bigwedge\limits_{i=1}^{1}(X_i\rightarrow Y) = x_1\rightarrow Y \label{EQ:ORATORIA_BI_1}\\
\end{align}

\subsection{Hipotésis inductiva} 
\begin{align}
\left(\bigvee\limits_{i=1}^{n}X_i\right)\rightarrow Y \Leftrightarrow \bigwedge\limits_{i=1}^{n}(X_i\rightarrow Y) 
\end{align}

Lo cual demuestra nuestra base.


\subsection{Tésis inductiva}


Resolviendo la tabla de verdad para $(A \rightarrow C) \wedge (B \rightarrow C)$:\\
\begin{center}
\begin{tabular}{| l | l | l | l | l | l |}
	A	&B	&C	&A$\rightarrow$C	&B$\rightarrow$C	&Resultado\\
	\hline
	1       &1       &1       &1       &1       &1\\
	1       &1       &0       &0       &0       &0\\
	1       &0       &1       &1       &1       &1\\
	1       &0       &0       &0       &1       &0\\
	0       &1       &1       &1       &1       &1\\
	0       &1       &0       &1       &0       &0\\
	0       &0       &1       &1       &1       &1\\
	0       &0       &0       &1       &1       &1\\
\end{tabular}
\end{center}


\[ (A \rightarrow Y) \wedge (B \rightarrow Y) =
 \begin{cases}
 0, 	\qquad& \text{si $Y=0$ y $(A\vee B) = 1$ }.\\
 1,	 	\qquad& \text{en otro caso}.\\
\end{cases} \]

Por lo cual podemos asociar $A$ y $B$ de esta manera:
\begin{equation}
(A \rightarrow Y) \wedge (B \rightarrow Y) = (A\vee B) \rightarrow Y = u \rightarrow Y
\end{equation}\label{EQ:ANDATORIA_PROPIEDAD_1}

Entonces, tomando nuestra hipótesis:
\begin{align}
\left(\bigvee\limits_{i=1}^{n}X_i\right)\rightarrow Y &= (x_1\vee x_2\vee \ldots \vee x_{n-1} \vee x_n)\rightarrow Y\label{EQ:ORATORIA_TI_1}\\
\bigwedge\limits_{i=1}^{n}(X_i\rightarrow Y) &= (x_1\rightarrow Y) \wedge (x_2\rightarrow Y) \wedge \ldots \wedge (x_{n-1}\rightarrow Y) \wedge (x_n\rightarrow Y) \label{EQ:ANDATORIA_TI_1}
\end{align}

Usando el cambio de variable \ref{EQ:ANDATORIA_PROPIEDAD_1} sobre la Operatoria \ref{EQ:ORATORIA_TI_1} y haciendo uso de la propiedad asociativa del operador $\vee$ tenemos:

\begin{align}
\bigwedge\limits_{i=1}^{n}(X_i\rightarrow Y) &= ((x_1\vee x_2)\rightarrow Y) \wedge ((x_3\vee x_4)\rightarrow Y) \wedge \ldots \wedge ((x_{n-1}\vee x_n)\rightarrow Y)
\nonumber\\
\bigwedge\limits_{i=1}^{n}(X_i\rightarrow Y) &= ((x_1\vee x_2\vee x_3 \vee x_4)\rightarrow Y) \wedge ((x_5\vee x_6\vee x_7 \vee x_8)\rightarrow Y) \wedge \ldots \wedge ((x_{n-3}\vee x_{n-2}\vee x_{n-1}\vee x_n)\rightarrow Y)
\nonumber\\
&\vdots\nonumber\\
\bigwedge\limits_{i=1}^{n}(X_i\rightarrow Y) &= ((x_1\vee x_2\vee \ldots \vee x_{n-1} \vee x_n)\rightarrow Y) \label{EQ:ANDATORIA_TI_2}
\end{align}

Es obvio que la Operatoria \ref{EQ:ANDATORIA_TI_2} es idéntica a la Operatoria \ref{EQ:ORATORIA_TI_1}, con lo cual, hemos demostrado que ambas expresiones son lógicamente equivalentes.
				\newpage
\section{Resolución de ecuaciones de recurrencia}

\subsection{Resolver mediante telescópica y función generatriz}
	\begin{center}
		f(x) = f$\left(\frac{x}{2}\right)$ + $\log_{2}(x)$, f(2) = 1.
	\end{center}
	\subsubsection{Telescópica:}
		\begin{center}	
			Haciendo n = 2$^{k}$, f(k) sería:\\
			f(2$^k$) = f(2$^{k-1}$) + k.\\
			Con s(k) = f(2$^{k}$), s(1) = f(2) = 1.
		\end{center}
		\begin{eqnarray*}
			s(k) &=& s(k-1) + k\\
			s(k-1) &=& s(k-2) + k-1\\
			&\vdots & \\
			s(2) &=& s(1) +2
		\end{eqnarray*}		
		\begin{center}
			Al sumar todo lo anterior se obtiene:\\
		\end{center}					
		\begin{eqnarray*}
			s(k) = \sum_{i=1}^{k} i = \frac{k(k+1)}{2} \text{ ; } k = \log_2 x\\
			f(x) = \frac{\log_2 x (\log_2 x + 1)}{2} \\
		\end{eqnarray*}

\subsection{Resolver con teorema maestro, polinómio característico y función generatriz}
	\begin{center}
		T(n) = 6T$\left(\frac{n}{6}\right)$ + 2n + 3, T(1) = 1.
	\end{center}
	\subsubsection{Mediante Teorema Maestro:}
		\begin{center}
			T(n) = n $\log{}(n)$
		\end{center}
	\subsubsection{Mediante Polinómio Característico:}
		\begin{center}	
			Haciendo n = 6$^{k}$, f(k) sería:
		\end{center}
		\begin{eqnarray}
			\label{EQ:PC2_1}f(k) = 6 \cdot f(k-1) + 2 \cdot 6^{k} + 3, f(0) = 1.\\
			\label{EQ:PC2_2}\text{Avanzando en 1:}\qquad f(k+1) = 6 \cdot f(k) + 12 \cdot 6^{k} + 3.\\
			\label{EQ:PC2_3}\text{De } \ref{EQ:PC2_2} - \ref{EQ:PC2_2} \qquad f(k+1) = 7 \cdot f(k) - 6 \cdot f(k-1) + 10 \cdot 6^{k}\\
			\label{EQ:PC2_4}\ref{EQ:PC2_3}+1 \qquad f(k+2) = 7 \cdot f(k+1) - 6 \cdot f(k) + 60 \cdot 6^{k}\\
			\label{EQ:PC2_5}\ref{EQ:PC2_3}\cdot6 \qquad 6 \cdot f(k+1) = 42 \cdot f(k) - 36 \cdot f(k-1) + 60 \cdot 6^{k}\\
			\label{EQ:PC2_6}\ref{EQ:PC2_4} - \ref{EQ:PC2_5} \qquad f(k+2) = 13 \cdot f(k+1) - 48 \cdot f(k) + 36 \cdot f(k-1)
		\end{eqnarray}
		\begin{eqnarray*}
			f(k+2) - 13 \cdot f(k+1) + 48 \cdot f(k) - 36 \cdot f(k-1) = 0\\
			\lambda^{k+2} - 13 \lambda^{k+1} + 48 \lambda^{k} - 36 \lambda^{k-1} = 0\\
			\lambda^{k-1}(\lambda^3 - 13\lambda^2 + 48\lambda - 36) = 0\\
			\text{Al simplificar y sacar raíces:} \qquad\\
			(\lambda - 6)^2 (\lambda - 1)
		\end{eqnarray*}		

\subsection{Resolver utilizando polinómio característico y función generatriz}
	\begin{center}
		T(n) = T$\left(\frac{n}{2}\right)$ + T$\left(\frac{n}{4}\right)$ + T$\left(\frac{n}{8}\right)$ + n , T(1) = 0, T(2) = 1, T(4) = 2.
	\end{center}	\newpage
\section{Fibonacci recursivo}
\subsection{Resolución analítica}
\begin{align}
	t_n = t_{n-1}t_{n-2}\nonumber\\
	t_1 = 1 ,\; t_2=2 \nonumber 	
\end{align}

Aplicando la propiedad aditiva de logaritmo:

\begin{align}
	&log_2(t_n)=log_2(t_{n-1} \; t_{n-2}) \nonumber\\
	&log_2(t_n)=log_2(t_{n-1})+log_2(t_{n-2}) \label{EQ:FIBO_RECURSIVO_1}\\
	&log_2(t_1=0)=1 \;,\; log_2(t_2=1)=2 \nonumber\\
\end{align}

Aplicando la transformación $f(n) = log(T(n))$ a la Ecuación \ref{EQ:FIBO_RECURSIVO_1}:

\begin{align}
	f(n) = f(n-1) + f(n-2) \label{EQ:FIBONACCI} \\
	f(n+2) = f(n+1) + f(n) \label{EQ:FIBONACCI_DESPLAZADO}\\
	f(0) = 1 \;,\; f(1) = 2 \nonumber
\end{align}

En donde la Ecuación Recursiva \ref{EQ:FIBONACCI} es posible resolverse usando la tecnica \textit{polinonio característico}.\footnote{Esta recursión es más conocida cómo la \textit{sucesión de fibonacci}} Para esto, se hace avanzar la Ecuación \ref{EQ:FIBONACCI} en dos pasos, lo cual nos deja con la Ecuación \ref{EQ:FIBO_RECURSIVO_1} a la cual, procedemos a extraer el polinomio caracteristico.

\begin{align}
	\lambda^{n+2} - \lambda^{n+1} - \lambda^{n} &= 0 \nonumber\\
	\lambda^{n}\;(\lambda^{2} - \lambda - 1) &= 0 \label{EQ:POLINOMIO_FIBONACCI_1}\\	
	\lambda^{2} - \lambda - 1 &= 0 \label{EQ:POLINOMIO_FIBONACCI_SIMP}\\
	\nonumber\\
	\lambda_1 = \frac{1+\sqrt{5}}{2} \nonumber\\
	\lambda_2 = \frac{1-\sqrt{5}}{2} \nonumber
\end{align}

De la Ecuación \ref{EQ:POLINOMIO_FIBONACCI_1} se tiene que $\lambda=0$ es solución del polinomio, sin embargo, por esto mismo es despreciado, lo cual nos deja con la Ecuación \ref{EQ:POLINOMIO_FIBONACCI_SIMP} como polinomio característico de la Ecuación \ref{EQ:FIBONACCI}. Entonces, ahora reemplazando en la matriz los casos base de la Ecuación \ref{EQ:FIBO_RECURSIVO_1} los valores obtenidos para $\lambda_1$ y $\lambda_2$ tenemos lo siguiente:

 
\begin{align}
	c_1 + c_2 &= f_0 = 0 \label{EQ:FIBO_MATRIX_1} \\
	c_1\;\lambda_{1} + c_2\;\lambda_{2} &= f_1 = 1 \label{EQ:FIBO_MATRIX_2}
\end{align}
Para la Ecuación \ref{EQ:FIBO_MATRIX_1} tenemos:
\begin{align}
	c_1 = -c_2 \label{EQ:FIBO_MATRIX_3}
\end{align}
Aplicando la Ecuación \ref{EQ:FIBO_MATRIX_3} en \ref{EQ:FIBO_MATRIX_2}:
\begin{align}
	c_1\lambda_1 - c_1\lambda_2&=1 \nonumber\\
	c_1\;(\lambda_1 +\lambda_2) &= 1\nonumber\\
	c_1 &= \frac{1}{\sqrt{5}} \nonumber\\
	c_2 &= -\frac{1}{\sqrt{5}} \nonumber
\end{align}

Ahora reemplazamos los valores obtenidos para $\lambda_1, \lambda_2, c_1, c_2$ en la fórmula del polinomio característico (\ref{EQ:POLINOMIO_CARACTERISTICO_DEFINICION}), dando lugar a la Ecuación \ref{EQ:VALOR_FIBONACCI}.
\begin{align}
	f_n &= c_1 \lambda_{1}^{n} + c_2 \lambda_{2}^{n} + \ldots + c_n \lambda_{n}^{n}\ \label{EQ:POLINOMIO_CARACTERISTICO_DEFINICION}\\	
	f_n &= c_1 \lambda_{1}^{n} + c_2 \lambda_{2}^{n}\nonumber\\	
	f_n &= \frac{1}{\sqrt{5}}\;\left(\frac{1+\sqrt{5}}{2}\right)^n -\frac{1}{\sqrt{5}}\;\left(\frac{1-\sqrt{5}}{2}\right)^n \label{EQ:VALOR_FIBONACCI}
\end{align}

Deshaciendo la transformación $f(n) = log(T(n))$:
\begin{align}
log_2(t_n)&= \frac{1}{\sqrt{5}}\;\left(\frac{1+\sqrt{5}}{2}\right)^n -\frac{1}{\sqrt{5}}\;\left(\frac{1-\sqrt{5}}{2}\right)^n \nonumber\\
t_n &= 2^{\left(\frac{1}{\sqrt{5}}\;\left(\frac{1+\sqrt{5}}{2}\right)^n -\frac{1}{\sqrt{5}}\;\left(\frac{1-\sqrt{5}}{2}\right)^n\right)}\nonumber\\
t_n&=2^{f(n)} \\
t_1 = f(0) = 1 \;&,\; t_2 = f(1) = 2
\end{align}

Donde $f_n$ es el $n$-ésimo término de la sucesión de fibonacci. Para efectos de cálculo, se usará directamente la recursión de fibonacci para obtener el valor a calcular, dado que por motivos de programación entera, el cálculo de la raíces provoca un error de precisión el cual arruina los resultados.

Usando el programa adjunto, se puede comprobar que el $25$-ésimo término de la recursión es aproximadamente $1.4415806\times10^{13951}$.

Para realizar la implementación del programa, se utilizó GNU MP\footnote{https://gmplib.org/manual/}. Esta es una librería escrita en C, orientada principalmente al trabajo con numeros racionales, enteros y flotantes de precisión infinita, enfocandose en el rendimiento independiente del tamaño del número a calcular. Hay actualmente incluso versiones en \textit{Assembler} optimizadas para muchos procesadores. Es software libre licenciado bajo la licencia \textbf{GNU LGPL v3}\footnote{https://www.gnu.org/licenses/lgpl.html} y \textbf{GNU GPL v2.0}\footnote{https://www.gnu.org/licenses/gpl-2.0.html}.

	\newpage

\section{Problema del logaritmo}
\subsection{Aproximación usando sumatoria por integral de $ln(n!)$}

Podemos descomponer $ln(n!)$ usando la propiedad aditiva, lo cual nos queda:
\begin{equation}
	ln(n!) = ln(1) + ln(2) + ln(3) + \ldots + ln(n-1) + ln(n) 
	=
	\sum_{i=1}^{n}ln(n)
\end{equation}\label{EQ:LOGARITMO_ADITIVA}
\begin{equation}\label{EQ:INTEGRAL_SUMATORIA}
	\sum_{}^{}ln(n) \simeq \int ln(n)\,dn
\end{equation}
\begin{equation}\label{EQ:LOGARITMO_COTA_INFERIOR_1}
	\int_{2}^{n+1} \! ln(n) \, \mathrm{d}n 
	\leq
	\sum_{i=1}^{n}ln(n)
\end{equation}
\begin{equation}\label{EQ:LOGARITMO_COTA_SUPERIOR_2}
	\sum_{i=1}^{n}ln(n)
	\leq
	\int_{1}^{n} \! ln(n) \, \mathrm{d}n 
\end{equation}

Sumatoria que usando el concepto de integral queda reescrita como la forma de la integral indefinida \ref{EQ:INTEGRAL_SUMATORIA}, permitiendo acotar la sumatoria anterior por \ref{EQ:LOGARITMO_COTA_INFERIOR_1} y \ref{EQ:LOGARITMO_COTA_SUPERIOR_2}.

%%\subsection{Desarrollo de la Ecuaci'on \ref{EQ:INTEGRAL_SUMATORIA}}
Usando integración por partes tenemos:
\begin{equation}
	\int ln(n)dn = n\;(ln(n)-1)
\end{equation}

\subsection{Cota inferior}
\begin{align}
	\int_{2}^{n+1} \! ln(n)\;dn &= n(ln(n)-1) \bigg|_{2}^{n+1} \nonumber \\
	&=(n+1)\;\left(ln(n+1)-1\right) - 2\;ln(2) - 1	\nonumber \\
	&=(n+1)\;\left(ln\left(\frac{n+1}{e}\right)\right)-2\;ln\left(\frac{2}{e}\right) \nonumber \\
	&=ln\left(\frac{(n+1)^{n+1}}{4e^{n-1}}\right) \label{EQ:CONCLUSION_COTA_INFERIOR}
\end{align}

\subsection{Cota superior}
\begin{align}
	\int_{1}^{n} \! ln(n)\;dn &= n(ln(n)-1) \bigg|_{1}^{n} \nonumber \\
	&=n\;\left(ln(n)-1\right) - 1 \nonumber \\
	&=n\;ln\left(\frac{n}{e}\right) - ln(e) \nonumber \\
	&=ln\left(\frac{n^{n}}{e^{n-1}}\right) \label{EQ:CONCLUSION_COTA_SUPERIOR}
\end{align}

\subsection{Conclusión}
Usando las Ecuación \ref{EQ:CONCLUSION_COTA_INFERIOR} y la Ecuación \ref{EQ:CONCLUSION_COTA_SUPERIOR}, podemos concluir que:
\begin{align}
	ln\left(\frac{n^{n}}{e^{n-1}}\right)
	\leq
	ln(n!)
	\leq
	ln\left(\frac{(n+1)^{n+1}}{4e^{n-1}}\right) \nonumber
\end{align}

\end{document}
